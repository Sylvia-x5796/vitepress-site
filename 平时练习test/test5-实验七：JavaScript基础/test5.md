# 实验七：JavaScript基础

## 一、实验目的与要求

### 实验目的
1. 掌握JavaScript的基本概念和作用
2. 理解JavaScript的基本语法规则
3. 掌握JavaScript的数据类型和变量声明
4. 学会使用JavaScript的运算符和表达式
5. 掌握JavaScript的控制语句（条件语句和循环语句）
6. 理解JavaScript函数的定义和调用方法
7. 了解JavaScript的数组和对象
8. 掌握DOM操作的基本方法
9. 了解JavaScript的事件处理

### 实验要求
1. 能够正确编写JavaScript代码
2. 掌握JavaScript的数据类型和变量声明方式
3. 能够使用JavaScript的运算符和表达式进行计算
4. 能够使用条件语句和循环语句控制程序流程
5. 理解函数的定义、调用和作用域
6. 能够创建和操作数组和对象
7. 掌握基本的DOM操作方法
8. 能够编写简单的事件处理函数
9. 能够使用浏览器的开发者工具调试JavaScript代码
10. 能够结合HTML和CSS实现简单的交互式网页功能

## 二、实验原理

## 三、实验环境

- 操作系统：Windows/macOS/Linux
- 文本编辑器：VS Code、Sublime Text、Notepad++等
- 浏览器：Google Chrome、Mozilla Firefox、Microsoft Edge或Apple Safari
- 开发者工具：浏览器内置的开发者工具（如Chrome DevTools）

## 四、实验任务

### 任务1：编写简单的JavaScript代码
1. 创建一个HTML文档
2. 在文档中添加JavaScript代码
3. 使用console.log()输出信息到控制台

### 任务2：使用变量和数据类型
1. 声明不同类型的变量和常量
2. 了解JavaScript的数据类型
3. 使用typeof操作符检查变量类型

### 任务3：使用运算符和表达式
1. 使用不同类型的运算符
2. 编写简单的表达式
3. 观察运算结果

### 任务4：使用控制语句
1. 编写条件语句
2. 编写循环语句
3. 观察控制语句的执行流程

### 任务5：定义和调用函数
1. 定义不同类型的函数
2. 调用函数并传递参数
3. 理解函数的返回值

### 任务6：使用数组
1. 创建和初始化数组
2. 使用数组的常用方法
3. 遍历数组

### 任务7：使用对象
1. 创建和初始化对象
2. 访问和修改对象的属性和方法
3. 遍历对象

### 任务8：DOM操作
1. 获取HTML元素
2. 修改元素的内容和样式
3. 创建和插入新元素

### 任务9：事件处理
1. 为HTML元素添加事件监听器
2. 编写事件处理函数
3. 观察事件的触发和处理过程

## 五、实验步骤与操作

### 步骤1：编写简单的JavaScript代码
1. 打开文本编辑器，创建一个名为`basic-javascript.html`的文件
2. 编写HTML文档的基本结构，并在body标签的末尾添加script标签
3. 保存文件，然后在浏览器中打开查看效果
4. 打开浏览器的开发者工具（通常按F12键），切换到"控制台"或"Console"选项卡，查看console.log()输出的信息

### 步骤2：使用变量和数据类型
1. 创建一个名为`variables-types.html`的文件
2. 编写HTML文档的基本结构，并在script标签中添加以下代码
3. 保存文件，然后在浏览器中打开查看效果
4. 打开浏览器的开发者工具，查看控制台输出的信息

### 步骤3：使用运算符和表达式
1. 创建一个名为`operators-expressions.html`的文件
2. 编写HTML文档的基本结构，并在script标签中添加以下代码
3. 保存文件，然后在浏览器中打开查看效果
4. 打开浏览器的开发者工具，查看控制台输出的信息

### 步骤4：使用控制语句
1. 创建一个名为`control-statements.html`的文件
2. 编写HTML文档的基本结构，并在script标签中添加以下代码
3. 保存文件，然后在浏览器中打开查看效果
4. 打开浏览器的开发者工具，查看控制台输出的信息

### 步骤5：定义和调用函数
1. 创建一个名为`functions.html`的文件
2. 编写HTML文档的基本结构，并在script标签中添加以下代码
3. 保存文件，然后在浏览器中打开查看效果
4. 打开浏览器的开发者工具，查看控制台输出的信息

### 步骤6：使用数组
1. 创建一个名为`arrays.html`的文件
2. 编写HTML文档的基本结构，并在script标签中添加以下代码
3. 保存文件，然后在浏览器中打开查看效果
4. 打开浏览器的开发者工具，查看控制台输出的信息

### 步骤7：使用对象
1. 创建一个名为`objects.html`的文件
2. 编写HTML文档的基本结构，并在script标签中添加以下代码
3. 保存文件，然后在浏览器中打开查看效果
4. 打开浏览器的开发者工具，查看控制台输出的信息

### 步骤8：DOM操作
1. 创建一个名为`dom-operations.html`的文件
2. 编写HTML文档的基本结构，并添加一些HTML元素和JavaScript代码
3. 保存文件，然后在浏览器中打开查看效果
4. 观察页面上HTML元素的变化

### 步骤9：事件处理
1. 创建一个名为`event-handling.html`的文件
2. 编写HTML文档的基本结构，并添加一些HTML元素和JavaScript代码
3. 保存文件，然后在浏览器中打开查看效果
4. 尝试与页面交互（点击按钮、移动鼠标、输入文本等），观察事件的触发和处理效果
5. 打开浏览器的开发者工具，查看控制台输出的信息

## 六、实验记录与分析

### 实验记录表格

| 实验内容 | 操作步骤 | 观察结果 | 分析与思考 |
|---------|---------|---------|-----------|
| 编写JavaScript代码 | 在HTML文档中添加script标签和JavaScript代码 | 代码在浏览器中执行 | JavaScript代码在HTML文档中有两个常用放置位置，一是`<head>`标签内（需搭配defer或async属性），二是`<body>`标签结束前（`</body>`上方）；放在`<head>`内时，若不添加相关属性，脚本会优先加载执行，可能因DOM尚未构建完成导致无法获取页面元素，而defer属性可让脚本在DOM解析完成后、DOMContentLoaded事件触发前执行，async属性能让脚本异步加载且加载完成后立即执行，二者均能避免阻塞DOM解析；放在`<body>`结束前是更推荐的方式，因为此时页面主要DOM元素已加载完毕，脚本可直接操作DOM，无需额外等待或处理加载顺序问题，同时不会阻塞页面渲染，能有效提升页面加载速度，保证脚本执行的准确性与用户体验的流畅性。 |
| 使用变量和数据类型 | 声明不同类型的变量和常量 | 变量和常量被正确赋值和使用 | var、let和const是JavaScript中声明变量的三种关键字，核心区别体现在作用域、提升行为、重复声明允许情况及值可变性上：var具有函数作用域（非块级作用域），存在变量提升且允许重复声明、值可修改，因易引发变量污染和逻辑错误，现代开发中已较少使用；let支持值修改，具有块级作用域（仅在{}内有效），不存在变量提升且存在暂时性死区、不允许重复声明，能有效避免变量污染；const同样是块级作用域、存在暂时性死区且不允许重复声明，同时声明时必须初始化，值不可直接修改（引用类型仅禁止重新赋值，内部属性可修改）。使用场景上，应优先使用const，用于声明值或引用无需改变的变量（如固定常量、不重新赋值的对象/数组），可提升代码可读性和稳定性；当变量的值需要后续修改时（如循环计数器、条件赋值的变量），则使用let；var仅在兼容旧版代码或需利用函数作用域的特殊场景下偶尔使用，不推荐在现代项目中新增使用。 |
| 使用运算符和表达式 | 使用不同类型的运算符 | 表达式被正确计算并返回结果 | JavaScript的运算符优先级规定了表达式中不同运算符的执行先后顺序，整体遵循“高优先级运算符先执行、同优先级运算符按结合性（多数从左到右，如算术、比较运算符；少数从右到左，如赋值、一元否定运算符）依次执行”的规则，具体优先级从高到低大致为：括号（()）最高，用于强制改变执行顺序；其次是一元运算符（如++、--、!）；再到算术运算符（先乘除取模、后加减）；接着是比较运算符（如>、<、===）；然后是逻辑运算符（先&&后||）；赋值运算符（如=、+=）优先级最低；为避免因优先级混淆导致表达式执行结果不符合预期，最直接有效的方法是在复杂表达式中通过括号明确指定运算顺序，即使优先级符合预期，适当添加括号也能提升代码可读性，同时建议熟悉常见运算符的核心优先级（如逻辑与&&优先级高于逻辑或||、严格相等===高于逻辑运算符），并保持代码表达式简洁、避免过度嵌套，以此减少优先级相关的逻辑错误。 |
| 使用控制语句 | 编写条件语句和循环语句 | 程序流程按照预期控制 | JavaScript的各类控制语句适用于不同的逻辑场景：if-else适合二选一的简单条件判断（如判断用户是否登录）；if-else if-else适用于多个互斥条件的连续判断（如根据分数划分等级）；switch-case更适合单个变量与多个固定值的匹配场景（如根据状态码返回提示信息），相比多重if-else结构更简洁易维护；for循环适合已知循环次数、需要计数器的场景（如遍历固定长度的数组）；for-in用于遍历对象的可枚举属性（需注意过滤原型链上的属性，不推荐用于数组遍历）；for-of适合遍历数组、字符串、Map、Set等可迭代对象，能直接获取元素值，比for-in更安全高效；while循环适用于循环次数不确定、依赖条件是否成立的场景（仅当条件为真时执行）；do-while循环同样适用于循环次数不确定，但需保证至少执行一次的场景（先执行循环体再判断条件）；break用于强制退出当前循环或switch语句，终止后续执行；continue用于跳过循环当前迭代的剩余代码，直接进入下一次循环；return用于函数内部，作用是返回指定值并立即退出函数，终止函数后续代码的执行。 |
| 定义和调用函数 | 定义不同类型的函数并调用 | 函数被正确执行并返回结果 | 函数声明和函数表达式是JavaScript中定义函数的两种方式，核心区别体现在提升行为、语法形式、调用时机和命名规则上：函数声明以`function`关键字开头且明确指定函数名，存在函数提升特性，在声明所在的全局或函数作用域内，可在函数声明前后任意位置调用，其函数名在整个作用域内可见；函数表达式则是将函数（可匿名，也可指定内部有效命名）赋值给变量，不存在函数提升，只能在赋值语句执行后才能调用，若为命名函数表达式，其函数名仅在函数内部可访问，外部无法通过该名称调用。箭头函数是ES6引入的函数表达式简洁写法，具有鲜明特点：语法极简，可省略`function`关键字，单参数时可省略括号，函数体仅含单条返回语句时可省略大括号和`return`关键字；核心特性是没有独立的`this`绑定，其`this`值继承自外层最近的非箭头函数的执行上下文，且无法通过`call`、`apply`、`bind`改变；不具备`arguments`对象，需通过剩余参数（`...args`）获取参数列表；不能作为构造函数使用（无法通过`new`关键字实例化），也没有`prototype`属性；同时不适用于需要动态`this`的场景（如对象方法、事件回调），更适合作为简单的回调函数（如数组遍历方法中的回调），能大幅简化代码结构。 |
| 使用数组 | 创建和操作数组 | 数组的元素和结构被正确修改 | JavaScript数组有多种常用方法，分别适用于元素增删、截取修改、合并转换、遍历处理、查找判断等场景：push()用于在数组尾部添加一个或多个元素，会改变原数组，返回新数组长度；pop()从数组尾部删除最后一个元素，改变原数组，返回被删除的元素；unshift()在数组头部添加元素，改变原数组，返回新长度；shift()从数组头部删除第一个元素，改变原数组，返回被删除的元素；slice(start, end)截取数组中从start索引到end索引（不包含end）的元素，不改变原数组，返回截取的新数组；splice(start, deleteCount, item1,...)可实现元素的删除、添加或替换，会改变原数组，返回被删除元素组成的数组；concat(arr1, arr2,...)用于合并多个数组或值，不改变原数组，返回合并后的新数组；join(separator)将数组元素按指定分隔符拼接为字符串，不改变原数组，返回拼接后的字符串；forEach((item, index, arr) => {})用于遍历数组，对每个元素执行回调函数，无返回值，不改变原数组（除非回调内手动修改）；map((item, index, arr) => {})遍历数组并对每个元素进行处理，返回由处理结果组成的新数组，不改变原数组；filter((item, index, arr) => {})筛选出符合回调函数条件的元素，返回由这些元素组成的新数组，不改变原数组；find((item, index, arr) => {})查找第一个符合条件的元素，返回该元素（无则返回undefined），不改变原数组；findIndex((item, index, arr) => {})查找第一个符合条件的元素的索引，返回该索引（无则返回-1），不改变原数组；some((item, index, arr) => {})判断数组中是否存在至少一个符合条件的元素，返回布尔值，不改变原数组；every((item, index, arr) => {})判断数组中所有元素是否都符合条件，返回布尔值，不改变原数组；reduce((acc, item, index, arr) => {}, initialValue)通过回调函数对数组元素进行累加、归约等操作，返回最终的累积结果，不改变原数组；sort((a, b) => {})对数组元素进行排序，会改变原数组，默认按字符串Unicode编码排序，需传入比较函数自定义排序规则；reverse()将数组元素反转顺序，会改变原数组，返回反转后的数组；includes(item, fromIndex)判断数组是否包含指定元素，返回布尔值，可通过fromIndex指定起始查找位置，不改变原数组。 |
| 使用对象 | 创建和操作对象 | 对象的属性和方法被正确访问和修改 | 使用构造函数创建JavaScript对象的方式为：先通过`function`关键字定义构造函数（通常首字母大写，内部通过`this`关键字绑定对象的属性和方法），再使用`new`关键字调用该构造函数，即可生成实例化对象，例如`function Person(name, age) { this.name = name; this.age = age; this.sayHi = () => console.log('Hi'); }`，通过`const person1 = new Person('Tom', 20)`就能创建包含对应属性和方法的对象实例；JavaScript对象与JSON的核心关系是“JSON基于对象字面量语法，但二者本质不同”——对象是JavaScript中的数据结构，用于存储和操作数据，支持函数、undefined等类型，属性名可省略引号；而JSON是一种轻量级数据交换文本格式，并非编程语言特性，其语法更严格（键名必须用双引号包裹，值仅支持字符串、数字、布尔值、null、数组、JSON对象，不支持函数、undefined等），二者可通过`JSON.stringify()`将JavaScript对象（符合JSON语法的部分）转换为JSON字符串，通过`JSON.parse()`将JSON字符串解析为JavaScript对象，实现数据的传输与解析。 |
| DOM操作 | 获取和修改HTML元素 | 页面元素的内容和样式被正确修改 | JavaScript要实现与HTML页面的动态交互，必须依赖DOM操作——DOM（文档对象模型）作为JavaScript与页面文档的桥梁，能让开发者动态查询、创建、修改或删除页面元素，调整元素的样式、属性与内容，还能绑定并响应用户的点击、输入等交互事件，进而实现表单验证、数据动态渲染、组件状态更新、弹窗交互等丰富功能，让静态的HTML页面具备灵活的交互能力，满足各类动态业务需求；而DOM操作对页面性能的核心影响在于，DOM属于浏览器渲染引擎的独立对象，与JavaScript运行环境分离，操作DOM会触发浏览器的重排（回流）和重绘：重排是当元素的布局、尺寸、位置或DOM结构改变时，浏览器需重新计算页面布局结构，重绘是当元素外观（如颜色、背景、字体）改变但不影响布局时，浏览器重新绘制元素，二者均需消耗系统资源，尤其频繁、零散的DOM操作（如循环中逐个添加元素、多次修改元素样式）会导致浏览器反复执行重排与重绘，造成页面卡顿、响应延迟，严重影响用户体验。 |
| 事件处理 | 为HTML元素添加事件监听器 | 事件被正确触发和处理 | 事件委托是JavaScript中基于事件冒泡机制实现的高效事件处理方式，核心原理是将原本需要绑定在多个子元素上的事件，统一绑定到它们的父元素（或更外层公共祖先元素）上，当子元素触发事件时，事件会逐级冒泡到父元素，再通过事件对象的`target`属性判断具体是哪个子元素触发了事件，进而执行对应的处理逻辑；其主要优势包括：一是大幅减少事件监听器的数量，避免给大量子元素（尤其是动态生成、数量较多的元素）逐个绑定事件，降低内存占用，提升页面性能；二是支持动态元素的事件处理，新增的子元素无需额外绑定事件，只要父元素存在，就能自动继承事件处理逻辑，简化代码维护；三是集中管理事件逻辑，所有相关子元素的事件处理统一在父元素的事件回调中，便于后续修改和维护，减少代码冗余。 |

### 分析与讨论
1. JavaScript的三种引入方式是什么？各有什么优缺点？
   JavaScript 的三种引入方式及优缺点。三种方式是行内式、内嵌式、外部引入式。行内式是直接写在 HTML 元素的事件属性里，优点是简单直接，缺点是耦合度高、可读性差、维护难，且无法复用；内嵌式是写在`<script>`标签内（head 或 body 里），优点是无需额外文件、加载快，缺点是代码与 HTML 混杂，不利于分离维护，大型项目不适用；外部引入式是通过`<script src="路径"></script>`引入外部.js 文件，优点是实现 HTML 与 JS 分离，代码复用性高、可读性强、便于维护，还能利用浏览器缓存，缺点是多一次 HTTP 请求，若路径错误会导致脚本失效，且需注意加载顺序问题。
2. JavaScript的数据类型有哪些？如何检测一个变量的数据类型？
   JavaScript 的数据类型及检测方式。数据类型分基本数据类型（字符串 string、数字 number、布尔值 boolean、undefined、null、Symbol、BigInt）和引用数据类型（对象 object，包含数组 array、函数 function、日期 Date 等）；检测方式主要有：typeof 运算符（适合检测基本数据类型，返回字符串类型结果，但 null 会误判为 object，函数返回 function）、instanceof 运算符（通过原型链检测引用数据类型，判断 A 是否是 B 的实例，不能检测基本数据类型）、Object.prototype.toString.call ()（最准确全面，返回 “[object 类型名]” 格式，可区分所有数据类型，包括 null、undefined 等）、constructor 属性（通过构造函数检测，如 num.constructor === Number，但可能被修改导致不准确）。
3. 什么是事件冒泡和事件捕获？如何控制事件的传播？
   事件冒泡、事件捕获及事件传播控制。事件捕获和事件冒泡是 DOM 事件流的两个阶段（事件流还包括目标阶段）：事件捕获是事件从最外层祖先元素向目标元素自上而下传播的阶段，即先触发外层元素事件，再触发内层目标元素事件；事件冒泡是事件从目标元素向最外层祖先元素自下而上传播的阶段，即先触发目标元素事件，再触发外层元素事件；控制事件传播的方式：通过 event.stopPropagation ()（阻止事件继续传播，包括捕获和冒泡阶段）或 event.stopImmediatePropagation ()（不仅阻止事件传播，还会阻止当前元素同一事件的其他监听器执行），此外，addEventListener () 方法的第三个参数（布尔值或选项对象）可指定事件处理在捕获阶段（true）或冒泡阶段（false，默认）执行，间接控制事件触发时机。
4. 什么是异步编程？JavaScript中处理异步操作的方式有哪些？
   异步编程及 JavaScript 处理异步的方式。异步编程是指代码执行不按顺序阻塞等待，而是在发起异步操作后继续执行后续代码，待异步操作完成后再回调处理结果的编程模式，其核心目的是避免耗时操作（如网络请求、定时器、文件读写）阻塞主线程，保证页面响应流畅；JavaScript 中处理异步操作的方式主要有：回调函数（最基础方式，将异步操作的结果处理逻辑传入回调函数，缺点是多层嵌套易形成 “回调地狱”，可读性差）、Promise 对象（ES6 引入，将异步操作封装为 Promise 实例，通过 then () 链式调用处理成功结果、catch () 处理失败，解决回调地狱，支持并行执行 Promise.all ()、Promise.race () 等）、async/await（ES7 语法糖，基于 Promise，用同步代码的写法实现异步操作，通过 async 声明异步函数，await 暂停函数执行等待 Promise resolve 结果，代码更简洁直观，可读性强），此外还有早期的 Generator 函数等方式，但现在已较少使用。

## 七、实验总结与思考

### 实验总结
JavaScript是Web前端开发的核心技术。通过本次实验，我们学习了JavaScript的基础知识，包括JavaScript的基本概念和作用、基本语法规则、数据类型、变量和常量、运算符和表达式、控制语句、函数、数组、对象、DOM操作以及事件处理。通过实际操作，我们掌握了如何编写和执行JavaScript代码，如何使用JavaScript来操作网页元素和响应用户交互。

### 思考与拓展
1. JavaScript与Java有什么关系？它们的主要区别是什么？
   JavaScript与Java仅名字相似、部分语法风格（如大括号、分号使用）相近，并无直接的继承或技术关联关系——Java是Sun公司（后被Oracle收购）推出的面向对象编译型语言，JavaScript则是网景公司为解决网页静态交互缺失问题设计的脚本语言，最初命名带有蹭Java热度的市场考量，本质是两款独立开发、定位完全不同的语言。二者的核心区别体现在多个关键维度：设计目标上，Java侧重企业级应用、跨平台桌面开发、后端服务及安卓应用开发，追求强稳定性与安全性；JavaScript核心定位是网页动态交互（如表单验证、元素操作），后通过Node.js扩展至后端开发，聚焦前端与轻量后端场景；语言类型上，Java是强类型语言，变量声明必须指定数据类型且不可随意变更，同时属于编译型语言，需先编译为字节码，再由Java虚拟机（JVM）执行；JavaScript是弱类型语言，变量无需指定类型，可动态切换数据类型，且为解释型语言，无需编译步骤，由浏览器或Node.js环境逐行解析执行；运行环境上，Java依赖JVM，可运行于Windows、Linux、服务器等多种平台，兼容性依赖JVM适配；JavaScript默认运行于各类浏览器，或通过Node.js运行于服务器端，无需额外虚拟机依赖；编程范式与语法细节上，Java严格遵循面向对象编程，以类为核心，必须通过类实例化对象，支持多继承（通过接口实现），有完善的包管理与异常处理机制；JavaScript早期基于原型实现面向对象，ES6后新增class语法但本质仍是原型继承，支持函数式编程，变量作用域（如函数作用域、块级作用域）与Java的类作用域、包作用域差异显著，且无需严格的类定义即可创建对象，语法更灵活松散。
2. 什么是ES6？ES6相比之前的版本增加了哪些新特性？
   ES6即ECMAScript 2015，是JavaScript语言的重要版本更新，相比ES5及之前的版本进行了大幅语法升级与功能扩展，奠定了现代JavaScript开发的基础，其新增的核心特性极大提升了代码的简洁性、可读性与开发效率：包括引入块级作用域变量声明关键字let和const，替代易引发变量污染的var；推出箭头函数，简化函数定义语法且继承外层this，避免传统函数this绑定混乱的问题；新增class类语法与extends继承机制，让面向对象编程更直观（本质仍是原型继承的语法糖）；引入模块系统（import/export），支持代码的模块化拆分与复用，解决了之前无原生模块的痛点；实现数组与对象的解构赋值，可快速提取数据，简化变量赋值操作；提供模板字符串，支持多行字符串与变量插值，替代繁琐的字符串拼接；新增Promise对象，搭配then()/catch()链式调用解决异步回调地狱问题；支持剩余参数（...args）与扩展运算符（...），便捷处理不定长参数与数组/对象的合并、展开；新增Set（无重复值集合）与Map（键值对集合，键可不为字符串）两种新数据结构，丰富数据存储方式；还优化了函数参数，支持默认参数赋值；后续迭代中补充的可选链操作符（?.）、空值合并运算符（??）等特性也常被纳入ES6相关实践，进一步降低了代码出错概率，让JavaScript更适配大型项目的开发需求。
3. 如何优化JavaScript代码的性能？
   优化JavaScript代码性能需从DOM操作、代码逻辑、资源加载、内存管理等核心维度综合发力，形成高效且易维护的优化方案：首先要减少频繁DOM交互，避免零散的元素查询、创建与样式修改，可通过缓存DOM查询结果、使用DocumentFragment批量处理元素、合并样式修改（如通过添加类名替代逐个修改style属性）等方式，减少浏览器重排与重绘的触发频次，降低渲染引擎负担；其次优化代码逻辑，避免全局变量污染（采用模块化封装或函数作用域限制变量范围），合理使用闭包（避免不必要的闭包导致内存占用过高），减少冗余计算（如循环中提前缓存数组长度、避免重复计算表达式结果），简化嵌套循环（拆分复杂循环或用Map/Set替代对象实现O(1)查找，提升数据操作效率），优先使用原生API（如数组的forEach、map等方法，或字符串的includes替代indexOf），避免自定义函数的额外开销；针对高频触发事件（如scroll、resize、input），需通过防抖（延迟执行，避免频繁触发）或节流（限制执行频率）控制回调执行次数，防止阻塞主线程；优化异步操作，用Promise.all/race并行处理多个独立异步任务，通过async/await简化异步逻辑、避免回调地狱，减少不必要的异步嵌套；资源加载层面，实现脚本、组件、图片的按需懒加载（避免首屏加载冗余资源），通过代码压缩（去除空格、注释）、Tree-Shaking剔除无用代码减小文件体积，利用浏览器缓存（缓存静态数据或重复使用的计算结果）减少重复请求与计算；同时做好内存管理，及时清理无用的事件监听、定时器、DOM引用（避免内存泄漏），释放不再使用的变量与对象，对于计算密集型任务（如大数据处理），可通过Web Workers在后台线程执行，避免阻塞UI渲染；此外，还需避免不必要的类型转换、减少函数调用栈深度，合理选择数据结构（如用Set去重、Map存储键值对，比对象更高效），进一步提升代码执行效率，确保页面运行流畅、响应迅速。
4. 什么是JavaScript框架和库？常见的JavaScript框架和库有哪些？
   JavaScript框架和库是构建JavaScript应用的核心生态组成，二者核心区别在于功能范围、使用方式与约束性：JavaScript库是封装了特定场景下常用功能（如DOM操作、网络请求、工具函数、数据可视化等）的代码集合，本质是“可按需调用的工具”，侵入性低，开发者拥有主导权，可根据需求挑选库中的功能嵌入项目，无需遵循固定架构；而JavaScript框架是提供完整开发解决方案的体系化工具，包含核心架构、路由管理、状态管理、组件机制等全套规范，本质是“约定开发规则的骨架”，侵入性强，开发者需遵循框架的设计理念与项目结构进行开发，框架主导整体开发流程。常见的JavaScript库有：jQuery（简化DOM操作、事件处理与AJAX请求，兼容旧浏览器）、Lodash（提供高效的数组/对象处理、函数防抖节流等工具函数，优化代码效率）、Axios（专注于HTTP网络请求，支持拦截器、请求取消、跨域等功能，适配浏览器与Node.js）、Chart.js/ECharts（轻量/功能丰富的数据可视化库，快速实现折线图、柱状图等图表）、Moment.js/date-fns（处理日期时间的格式化、解析与计算）；常见的JavaScript框架有：Vue.js（轻量易用、双向数据绑定，适合中小型应用与组件化开发，生态完善）、React（基于虚拟DOM与组件化思想，采用JSX语法，适合大型复杂应用，可通过React Native实现跨端开发）、Angular（由Google维护的全功能框架，内置路由、表单验证、依赖注入等，适合企业级大型应用）、Svelte（编译时框架，无需虚拟DOM，直接生成原生DOM代码，性能优异，语法简洁）、Next.js/Nuxt.js（分别基于React/Vue的服务端渲染（SSR）/静态站点生成（SSG）框架，优化首屏加载速度与SEO）。
5. 未来JavaScript的发展趋势是什么？
   未来JavaScript的发展趋势将围绕“提升开发效率、强化跨场景能力、优化性能体验”三大核心展开，呈现多维度深度进化的态势：语言本身将持续迭代，不断新增更实用的原生特性（如更灵活的异步处理语法、原生类型增强、更便捷的数据操作API等），进一步降低开发复杂度，让代码更简洁安全；与TypeScript的深度融合成为必然，静态类型检查能有效减少大型项目的运行时错误，已逐渐成为企业级开发的主流选择，未来JavaScript生态将更紧密地兼容TypeScript，甚至原生语言可能吸纳更多类型相关特性；跨端开发能力将持续深化，基于Node.js、Electron、React Native、Vue Native等技术，“一次编写、多端运行”的覆盖范围将进一步扩大，不仅能适配网页、桌面应用、移动端，还将向小程序、嵌入式设备等更多场景延伸，实现全场景开发统一；与WebAssembly的协同将更加成熟，JavaScript负责处理交互逻辑、DOM操作等场景，而计算密集型、性能敏感型任务（如3D渲染、大数据处理、复杂算法）则交给WebAssembly执行，二者优势互补，大幅提升应用整体性能上限；Serverless架构在JavaScript后端开发中的应用将更广泛，开发者无需关注服务器部署与运维，专注于核心业务逻辑，让后端开发更轻量化、低成本；AI与机器学习将深度融入JavaScript生态，通过TensorFlow.js、Brain.js等库，实现浏览器端或Node.js环境下的AI模型推理、图像识别、自然语言处理等功能，推动智能交互类应用（如实时语音翻译、个性化推荐）的普及；前端工程化将向更高效、更规范的方向发展，模块化、组件化开发模式完全普及，构建工具（如Vite）、测试工具、代码检查工具的自动化与智能化程度持续提升，同时生态系统将不断完善，涌现更多适配特定场景（如低代码、可视化编程）的专用库与框架，进一步降低开发门槛，让JavaScript在全栈开发、智能应用、跨端场景中持续占据核心地位。