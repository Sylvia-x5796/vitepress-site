# CSS优化个人主页实验报告

## 基本信息
- **姓名**：[肖息]
- **学号**：[222023321062059]
- **班级**：[2023级软工中外02班]

## 实验目的

1. 掌握CSS的基本语法和引入方式
2. 能够使用CSS选择器精确选择HTML元素
3. 理解CSS盒模型并应用于页面布局
4. 掌握常用CSS属性，如文本样式、颜色、背景等
5. 能够使用浮动、定位和Flexbox进行页面布局
6. 了解响应式设计的基本概念和实现方法
7. 能够使用CSS过渡和动画增强用户体验

## 实验环境
- **操作系统**：[例如：Windows 10 / macOS]
- **开发工具**：[例如：VS Code / Sublime Text]
- **浏览器**：[例如：Chrome / Firefox / Safari]

## 实验内容与过程

### 1. HTML文档准备
准备HTML文档，包括：
- 使用了实践项目1中的HTML文档
- 对HTML文档做修改，以适应CSS样式
- 添加了新的HTML元素或结构

### 2. CSS文件创建与引入
创建和引入CSS文件：
- CSS文件的命名和位置
- 在HTML文档中引入CSS文件
- 可使用其他引入方式（如内联样式、内部样式表）

### 3. CSS样式实现

#### 3.1 全局样式和重置
- 重置浏览器默认样式
- 设置全局样式

#### 3.2 页面头部样式
- 页面头部的背景、颜色、字体等设计
- 导航菜单的布局和样式
- 使用固定定位或其他定位方式

#### 3.3 主要内容区域样式
- 各个部分的布局和设计
- 使用布局技术（Flexbox、Grid等）
- 处理图片、表格、列表等元素的样式

#### 3.4 联系方式和表单样式
- 联系方式部分的样式设计
- 表单元素的样式和交互效果
- 表单验证的交互反馈（如果有）

#### 3.5 页面底部样式
- 页面底部的设计和布局
- 添加额外的信息或功能

### 4. 响应式设计实现
实现响应式设计：
- 使用媒体查询
- 针对不同屏幕尺寸做调整
- 处理图片、表格等元素的响应式显示

## 实验结果与分析

### 1. 页面效果展示

请提供你的个人主页在不同设备上的截图（至少包括桌面端和移动端）：

#### 桌面端效果
![桌面端效果](./images/desk-screen.png)

#### 移动端效果
![移动端效果](截图文件名)

### 2. CSS技术分析

分析你在实验中使用的CSS技术，比如：
- 使用了哪些CSS选择器，它们的特点和优势是什么
- 如何应用CSS盒模型，遇到了哪些问题，如何解决
- 使用了哪些布局技术，为什么选择这些技术

### 3. 响应式设计分析

分析你的响应式设计实现，比如：
- 选择了哪些断点，为什么
- 针对不同设备做了哪些优化
- 响应式设计中有哪些挑战，如何解决

## 实验总结与体会

### 1. 实验收获

总结你在本次实验中的收获，比如：
- 对CSS的理解有哪些提升
- 掌握了哪些新的CSS技术和技巧
- 对前端开发有哪些新的认识

### 2. 遇到的问题与解决方案

描述你在实验过程中遇到的主要问题和解决方案，比如：
- 遇到了哪些技术难题
- 如何查找资料和解决问题
- 从这些问题中学到了什么

### 3. 实验反思

对本次实验的反思：
- 实验中有哪些可以改进的地方
- 对CSS学习有哪些新的思考
- 未来如何进一步提升CSS技能

## 扩展思考

1. CSS预处理器（如Sass、Less）相比原生CSS有哪些优势？
2. CSS框架（如Bootstrap、Tailwind CSS）在实际项目中的应用场景和优缺点是什么？
3. 如何在保证视觉效果的同时，优化CSS性能？
4. CSS在未来Web开发中的发展趋势是什么？
5. 如何平衡设计美观性和代码可维护性？

## 代码附录

请附上你的主要CSS代码（选择最核心、最能体现你技术水平的部分）：

```css
/* 全局重置：统一浏览器默认样式，避免兼容性问题 */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box; /* 核心盒模型，避免宽高计算偏差 */
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}

/* CSS变量：集中管理样式原子，支持全局统一修改，降低维护成本 */
:root {
    --primary: #165DFF;
    --primary-dark: #0f48d1;
    --light-bg: #f5f7fa;
    --card-bg: #fff;
    --text-main: #333;
    --text-secondary: #666;
    --border-light: #eee;
    --shadow-sm: 0 3px 15px rgba(0, 0, 0, 0.05);
    --shadow-md: 0 4px 15px rgba(0, 0, 0, 0.1);
    --radius: 12px;
    --section-padding: 60px 0;
    --card-margin: 20px;
    --transition-default: all 0.3s ease; /* 统一过渡效果，保证动画一致性 */
}

/* 响应式网格布局：自动适配容器宽度，无需手动写媒体查询控制列数 */
.skills-list {
    margin-top: 20px;
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); /* 核心自适应逻辑 */
    gap: 20px;
}

/* Flex布局：实现垂直居中、两端对齐、响应式换行 */
.header-content {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 15px 0;
}

.hobbies {
    list-style: none;
    display: flex;
    flex-wrap: wrap; /* 自动换行，适配小屏幕 */
    gap: 15px;
    justify-content: center;
}

/* 滚动入场动画：提升页面交互质感 */
section {
    padding: var(--section-padding);
    opacity: 0;
    transform: translateY(30px);
    transition: opacity 0.6s ease, transform 0.6s ease; /* 分离透明度和位移动画 */
}

section.visible {
    opacity: 1;
    transform: translateY(0);
}

/* 导航链接hover动画：细节交互优化 */
nav a {
    position: relative;
}

nav a::after {
    content: '';
    position: absolute;
    left: 0;
    bottom: 0;
    width: 0;
    height: 2px;
    background-color: var(--primary);
    transition: width 0.3s ease; /* 仅过渡宽度，性能更优 */
}

nav a:hover::after {
    width: 100%; /* 下划线平滑展开 */
}

/* 按钮交互：多状态反馈 */
.btn-submit {
    background-color: var(--primary);
    color: #fff;
    border: none;
    padding: 15px;
    border-radius: 8px;
    cursor: pointer;
    transition: var(--transition-default);
}

.btn-submit:hover {
    background-color: var(--primary-dark);
    transform: translateY(-2px); /* 微上浮效果，增强点击欲望 */
}

/* 表单焦点状态：提升可访问性 */
.form-control:focus {
    outline: none;
    border-color: var(--primary);
    box-shadow: 0 0 0 3px rgba(22, 93, 255, 0.1); /* 柔和焦点阴影，不刺眼 */
}

/* 断点分层：按设备尺寸精细化适配（768px/480px 覆盖主流设备） */
@media (max-width: 768px) {
    :root {
        --section-padding: 40px 0;
        --card-margin: 15px; /* 响应式下动态修改CSS变量，无需重复写样式 */
    }

    /* 汉堡菜单：移动端导航解决方案 */
    .hamburger {
        display: block;
    }

    nav ul {
        display: none;
        flex-direction: column;
        position: absolute;
        top: 70px;
        left: 0;
        width: 100%;
        background-color: var(--card-bg);
        box-shadow: 0 5px 10px rgba(0, 0, 0, 0.1);
        padding: 20px;
        gap: 15px;
    }

    nav ul.show {
        display: flex; /* 通过类控制显示隐藏，配合JS实现交互 */
    }

    /* 组件适配：横向布局转纵向布局 */
    #about .about-content {
        flex-direction: column;
        text-align: center;
    }

    .slider {
        height: 300px; /* 适配小屏幕的轮播高度 */
    }
}

@media (max-width: 480px) {
    :root {
        --section-padding: 30px 0;
        --card-margin: 10px;
    }

    .skills-list {
        grid-template-columns: 1fr; /* 超小屏幕下单列布局 */
    }

    .contact-list {
        flex-direction: column; /* 联系方式纵向排列 */
    }
}
```

我的主要js代码（选择最核心、最能体现你技术水平的部分）：

```js
// 图片轮播 - 完整功能实现（自动轮播+手动控制+状态切换+动态DOM）
const slider = document.querySelector('.slider');
const slides = document.querySelectorAll('.slide');
const prevBtn = document.querySelector('.prev');
const nextBtn = document.querySelector('.next');
const dots = document.querySelectorAll('.dot');
let currentIndex = 0;
let slideInterval;
let isPlaying = true;

// 核心：显示指定索引幻灯片（处理边界+状态同步）
function showSlide(index) {
    // 隐藏所有幻灯片+移除指示器激活状态（统一重置）
    slides.forEach(slide => slide.classList.remove('active'));
    dots.forEach(dot => dot.classList.remove('active'));
    
    // 边界处理：确保索引循环（避免越界）
    currentIndex = (index + slides.length) % slides.length;
    
    // 激活当前状态
    slides[currentIndex].classList.add('active');
    dots[currentIndex].classList.add('active');
}

// 上一张/下一张逻辑（复用showSlide，避免代码冗余）
function prevSlide() { showSlide(currentIndex - 1); }
function nextSlide() { showSlide(currentIndex + 1); }

// 事件绑定：按钮+指示器（多元素统一处理）
prevBtn.addEventListener('click', prevSlide);
nextBtn.addEventListener('click', nextSlide);
dots.forEach((dot, index) => dot.addEventListener('click', () => showSlide(index)));

// 自动轮播+鼠标悬停暂停（体验优化）
function startSlideInterval() {
    slideInterval = setInterval(nextSlide, 5000);
}
slider.addEventListener('mouseenter', () => clearInterval(slideInterval));
slider.addEventListener('mouseleave', () => isPlaying && startSlideInterval());

// 动态创建暂停/播放按钮（无需HTML冗余，体现DOM操作能力）
const playPauseBtn = document.createElement('button');
playPauseBtn.className = 'slider-btn play-pause';
playPauseBtn.innerHTML = '<i class="fas fa-pause"></i>';
playPauseBtn.style.top = '20px';
playPauseBtn.style.right = '20px';
document.querySelector('.slider-container').appendChild(playPauseBtn);

// 暂停/播放状态切换（状态管理核心）
playPauseBtn.addEventListener('click', () => {
    if (isPlaying) {
        clearInterval(slideInterval);
        playPauseBtn.innerHTML = '<i class="fas fa-play"></i>';
    } else {
        startSlideInterval();
        playPauseBtn.innerHTML = '<i class="fas fa-pause"></i>';
    }
    isPlaying = !isPlaying;
});

// 初始化（确保页面加载即正常运行）
showSlide(0);
startSlideInterval();

// 滚动渐入动画 - 精准判断元素可见性
function checkVisibility() {
    const sections = document.querySelectorAll('section');
    sections.forEach(section => {
        // 核心：用getBoundingClientRect()判断元素与视口的位置关系
        const rect = section.getBoundingClientRect();
        // 触发条件：版块顶部进入视口底部100px内（避免过早/过晚触发，提升体验）
        if (rect.top < window.innerHeight - 100) {
            section.classList.add('visible');
        }
    });
}

// 双触发时机：初始加载+滚动时（确保所有场景都能触发）
window.addEventListener('load', checkVisibility);
window.addEventListener('scroll', checkVisibility);

// 表单验证 - 多字段规则校验+即时反馈
const contactForm = document.getElementById('contactForm');
if (contactForm) { // 容错处理：避免元素不存在时报错
    contactForm.addEventListener('submit', function(e) {
        e.preventDefault(); // 阻止默认提交行为
        let isValid = true; // 验证状态标记
        
        // 1. 姓名验证（非空校验）
        const name = document.getElementById('name');
        const nameError = document.getElementById('nameError');
        if (!name.value.trim()) {
            nameError.textContent = '请输入姓名';
            nameError.style.display = 'block';
            isValid = false;
        } else {
            nameError.style.display = 'none';
        }
        
        // 2. 邮箱验证（正则表达式+格式校验）
        const email = document.getElementById('email');
        const emailError = document.getElementById('emailError');
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        if (!emailRegex.test(email.value)) {
            emailError.textContent = '请输入有效的邮箱地址';
            emailError.style.display = 'block';
            isValid = false;
        } else {
            emailError.style.display = 'none';
        }
        
        // 3. 留言验证（长度校验）
        const message = document.getElementById('message');
        const messageError = document.getElementById('messageError');
        if (message.value.trim().length < 5) {
            messageError.textContent = '留言内容至少5个字符';
            messageError.style.display = 'block';
            isValid = false;
        } else {
            messageError.style.display = 'none';
        }
        
        // 验证通过：模拟提交+重置表单
        if (isValid) {
            alert('留言提交成功！');
            contactForm.reset();
        }
    });
}
```